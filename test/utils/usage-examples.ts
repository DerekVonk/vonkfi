/**
 * Enhanced Test Data Isolation Usage Examples
 * 
 * This file demonstrates how to use the enhanced test isolation system
 * for production-ready test data management.
 */

import { describe, it, beforeEach, afterEach, expect } from 'vitest';
import { 
  initializeEnhancedIsolation, 
  getEnhancedIsolationManager,
  PRODUCTION_ISOLATION_CONFIG 
} from './enhanced-test-isolation-config';
import { TestDatabaseHelpers } from './test-db-helpers';
import { createTestNamespace, cleanupTestNamespace } from './test-data-namespacing';
import { withIsolatedSchema } from './schema-isolation-system';

// Example 1: Basic Namespace Isolation
describe('Example 1: Basic Namespace Isolation', () => {
  let testEnvironment: any;
  
  beforeEach(async () => {
    const manager = initializeEnhancedIsolation();
    testEnvironment = await manager.createIsolatedTestEnvironment(
      'user-management.test.ts',
      'should create user with valid data',
      {
        isolationLevel: 'namespace',
        cleanupStrategy: 'immediate'
      }
    );
  });
  
  afterEach(async () => {
    if (testEnvironment) {\n      await testEnvironment.cleanup();\n    }\n  });\n  \n  it('should create user with proper isolation', async () => {\n    // Your test code here - all data will be namespaced and isolated\n    expect(testEnvironment.namespaceId).toBeDefined();\n    \n    // Get metrics for monitoring\n    const metrics = testEnvironment.getMetrics();\n    expect(metrics.namespaceMetrics).toBeDefined();\n  });\n});\n\n// Example 2: Schema-Level Isolation\ndescribe('Example 2: Schema-Level Isolation', () => {\n  it('should use isolated schema for complex tests', async () => {\n    const result = await withIsolatedSchema(\n      'complex-migration.test.ts',\n      'should migrate data correctly',\n      async (schemaName, leaseId) => {\n        // Test runs in completely isolated schema\n        console.log(`Running test in schema: ${schemaName}`);\n        \n        // Your test logic here\n        return { success: true, schemaName };\n      }\n    );\n    \n    expect(result.success).toBe(true);\n    expect(result.schemaName).toMatch(/test_schema_/);\n  });\n});\n\n// Example 3: Transaction-Level Isolation with Deadlock Detection\ndescribe('Example 3: Transaction Isolation with Monitoring', () => {\n  it('should handle transactions with deadlock detection', async () => {\n    const result = await TestDatabaseHelpers.withTransaction(\n      'transaction-test.ts',\n      'should handle concurrent operations',\n      async (leaseId, transaction) => {\n        // Enhanced transaction with monitoring\n        expect(transaction.transactionId).toBeDefined();\n        expect(transaction.deadlockDetected).toBe(false);\n        \n        // Simulate some database operations\n        // transaction.queryCount will be automatically tracked\n        \n        await transaction.commit();\n        return { transactionId: transaction.transactionId };\n      },\n      {\n        isolationLevel: 'READ_COMMITTED',\n        enableDeadlockDetection: true,\n        enablePerformanceMonitoring: true,\n        priority: 'high',\n        maxRetries: 3\n      }\n    );\n    \n    expect(result.transactionId).toBeDefined();\n  });\n});\n\n// Example 4: Hybrid Isolation Strategy\ndescribe('Example 4: Hybrid Isolation Strategy', () => {\n  let manager: any;\n  \n  beforeEach(() => {\n    // Initialize with hybrid strategy (both namespace and schema isolation)\n    manager = initializeEnhancedIsolation({\n      ...PRODUCTION_ISOLATION_CONFIG,\n      isolationLevel: 'hybrid',\n      enablePerformanceMonitoring: true,\n      enableDeadlockDetection: true\n    });\n  });\n  \n  afterEach(async () => {\n    if (manager) {\n      manager.destroy();\n    }\n  });\n  \n  it('should use hybrid isolation for maximum safety', async () => {\n    const environment = await manager.createIsolatedTestEnvironment(\n      'critical-business-logic.test.ts',\n      'should process financial transactions',\n      {\n        isolationLevel: 'hybrid',\n        enableMonitoring: true\n      }\n    );\n    \n    try {\n      // Both namespace and schema isolation active\n      expect(environment.namespaceId).toBeDefined();\n      expect(environment.schemaName).toBeDefined();\n      \n      // Your critical test logic here\n      // Full isolation and monitoring active\n      \n      const metrics = environment.getMetrics();\n      console.log('Test metrics:', metrics);\n      \n    } finally {\n      await environment.cleanup();\n    }\n  });\n});\n\n// Example 5: Performance-Critical Tests with Row-Level Locking\ndescribe('Example 5: Row-Level Locking for Performance Tests', () => {\n  it('should handle concurrent access with row-level locks', async () => {\n    const result = await TestDatabaseHelpers.withRowLevelLocking(\n      'concurrency-test.ts',\n      'should handle concurrent updates',\n      'accounts', // table name\n      'id = $1', // where clause\n      [123], // parameters\n      async (leaseId) => {\n        // Critical section with row locked\n        // Your concurrent access test logic here\n        return { success: true };\n      },\n      {\n        lockMode: 'FOR UPDATE',\n        lockTimeout: 5000,\n        nowait: false\n      }\n    );\n    \n    expect(result.success).toBe(true);\n  });\n});\n\n// Example 6: Custom Cleanup Strategy\ndescribe('Example 6: Custom Cleanup Strategy', () => {\n  it('should use deferred cleanup for performance', async () => {\n    const namespace = await createTestNamespace(\n      'performance-test.ts',\n      'should handle large dataset',\n      {\n        cleanupStrategy: 'deferred',\n        maxEntityLimit: 50000,\n        isolationLevel: 'namespace'\n      }\n    );\n    \n    try {\n      // Create large test dataset\n      // Cleanup will be deferred for better performance\n      \n      expect(namespace.id).toBeDefined();\n      expect(namespace.cleanupStrategy).toBe('deferred');\n      \n    } finally {\n      // Manual cleanup when ready\n      await cleanupTestNamespace(namespace.id);\n    }\n  });\n});\n\n// Example 7: Error Handling and Recovery\ndescribe('Example 7: Error Handling and Recovery', () => {\n  it('should recover gracefully from errors', async () => {\n    let errorCaught = false;\n    \n    try {\n      await TestDatabaseHelpers.withTransaction(\n        'error-test.ts',\n        'should handle database errors',\n        async (leaseId, transaction) => {\n          // Simulate an error that should trigger rollback\n          throw new Error('Simulated database error');\n        },\n        {\n          maxRetries: 2,\n          enableDeadlockDetection: true\n        }\n      );\n    } catch (error) {\n      errorCaught = true;\n      expect(error.message).toBe('Simulated database error');\n    }\n    \n    expect(errorCaught).toBe(true);\n    \n    // Check that cleanup happened automatically\n    const stats = TestDatabaseHelpers.getTestDatabaseStats();\n    expect(stats.activeTransactions).toBe(0);\n  });\n});\n\n// Example 8: Health Monitoring and Metrics\ndescribe('Example 8: Health Monitoring', () => {\n  it('should provide comprehensive health metrics', async () => {\n    const manager = getEnhancedIsolationManager();\n    if (!manager) {\n      throw new Error('Manager not initialized');\n    }\n    \n    const healthCheck = await manager.performHealthCheck();\n    \n    expect(healthCheck).toHaveProperty('healthy');\n    expect(healthCheck).toHaveProperty('issues');\n    expect(healthCheck).toHaveProperty('metrics');\n    \n    // Log comprehensive report\n    const report = manager.generateReport();\n    expect(report).toContain('ENHANCED TEST ISOLATION REPORT');\n    \n    console.log('Health check:', healthCheck);\n    console.log('Full report:', report);\n  });\n});\n\n// Example 9: CI/CD Optimized Configuration\ndescribe('Example 9: CI/CD Configuration', () => {\n  it('should use CI-optimized settings', async () => {\n    const manager = initializeEnhancedIsolation({\n      isolationLevel: 'schema',\n      enableSecurityValidation: true,\n      enablePerformanceMonitoring: false, // Reduced overhead in CI\n      enableDeadlockDetection: true,\n      cleanupStrategy: 'immediate',\n      timeoutSettings: {\n        connection: 15000,\n        transaction: 45000,\n        cleanup: 90000,\n        migration: 180000\n      },\n      maxConcurrentOperations: 10 // Reduced for CI resources\n    });\n    \n    const environment = await manager.createIsolatedTestEnvironment(\n      'ci-test.ts',\n      'should run efficiently in CI'\n    );\n    \n    try {\n      // CI-optimized test execution\n      expect(environment.schemaName).toBeDefined();\n      \n    } finally {\n      await environment.cleanup();\n      manager.destroy();\n    }\n  });\n});\n\n// Example 10: Security Validation\ndescribe('Example 10: Security Validation', () => {\n  it('should prevent SQL injection attempts', async () => {\n    let securityViolationCaught = false;\n    \n    try {\n      await createTestNamespace(\n        'security-test.ts',\n        'should block malicious input; DROP TABLE users; --',\n        {\n          isolationLevel: 'namespace'\n        }\n      );\n    } catch (error) {\n      securityViolationCaught = true;\n      expect(error.message).toContain('Security violation');\n    }\n    \n    expect(securityViolationCaught).toBe(true);\n  });\n});\n\n/*\n * USAGE GUIDELINES:\n * \n * 1. Always use the appropriate isolation level for your test:\n *    - 'namespace': Fast, good for unit tests\n *    - 'schema': Complete isolation, good for integration tests\n *    - 'transaction': Atomic operations, good for data consistency tests\n *    - 'hybrid': Maximum safety, good for critical business logic tests\n * \n * 2. Enable monitoring in production-like environments:\n *    - enablePerformanceMonitoring: true for detecting slow operations\n *    - enableDeadlockDetection: true for concurrent access patterns\n *    - enableSecurityValidation: true for input validation\n * \n * 3. Choose appropriate cleanup strategies:\n *    - 'immediate': Clean up right after test (safest)\n *    - 'deferred': Clean up in batches (better performance)\n *    - 'manual': Clean up when explicitly called (full control)\n * \n * 4. Configure timeouts based on your test complexity:\n *    - Short timeouts for simple tests\n *    - Longer timeouts for complex integration tests\n *    - Very long timeouts for migration tests\n * \n * 5. Use health monitoring and metrics:\n *    - Call performHealthCheck() regularly\n *    - Monitor generateReport() output\n *    - Set up alerts for high error rates or resource usage\n * \n * 6. Handle errors gracefully:\n *    - Always use try/finally blocks\n *    - Implement proper cleanup in error scenarios\n *    - Use retry mechanisms for transient failures\n * \n * 7. Optimize for your environment:\n *    - Use DEVELOPMENT_ISOLATION_CONFIG in development\n *    - Use CI_ISOLATION_CONFIG in CI/CD pipelines\n *    - Use PRODUCTION_ISOLATION_CONFIG for production-like testing\n */